import requests
import json
import re
import ssl
import socket
from urllib.parse import urljoin, urlparse
from datetime import datetime
import threading
import time
from models import ScanSession, Finding, db
from crypto_utils import encrypt_data
from anonymity_manager import AnonymityManager
import logging

class VulnerabilityScanner:
    def __init__(self):
        self.anonymity = AnonymityManager()
        self.is_scanning = False
        self.cve_database = {}
        self.load_cve_database()
    
    def load_cve_database(self):
        """Load CVE database for vulnerability matching"""
        try:
            # In a real implementation, this would load from NIST NVD API
            # For now, we'll use a simplified structure
            self.cve_database = {
                'apache': {
                    'CVE-2021-44228': {
                        'description': 'Apache Log4j2 Remote Code Execution',
                        'cvss_score': 10.0,
                        'severity': 'critical'
                    }
                },
                'openssh': {
                    'CVE-2020-15778': {
                        'description': 'OpenSSH Username Enumeration',
                        'cvss_score': 5.3,
                        'severity': 'medium'
                    }
                },
                'mysql': {
                    'CVE-2019-2740': {
                        'description': 'MySQL Server Privilege Escalation',
                        'cvss_score': 6.5,
                        'severity': 'medium'
                    }
                }
            }
        except Exception as e:
            logging.error(f"Failed to load CVE database: {str(e)}")
    
    def scan_vulnerabilities(self, session_id, targets, scan_config):
        """
        Perform comprehensive vulnerability scanning
        """
        try:
            session = ScanSession.query.get(session_id)
            if not session:
                logging.error(f"Scan session {session_id} not found")
                return False
            
            session.status = 'running'
            db.session.commit()
            
            self.is_scanning = True
            
            # Setup anonymity if required
            if scan_config.get('use_anonymity', True):
                self.anonymity.setup_tor_proxy()
            
            for target in targets:
                if not self.is_scanning:
                    break
                
                # Perform various vulnerability checks
                self._check_ssl_vulnerabilities(session_id, target)
                self._check_service_vulnerabilities(session_id, target)
                self._check_web_vulnerabilities(session_id, target)
                self._check_network_vulnerabilities(session_id, target)
            
            session.status = 'completed'
            db.session.commit()
            self.is_scanning = False
            
            return True
            
        except Exception as e:
            logging.error(f"Vulnerability scan failed: {str(e)}")
            session.status = 'failed'
            db.session.commit()
            self.is_scanning = False
            return False
    
    def _check_ssl_vulnerabilities(self, session_id, target):
        """Check for SSL/TLS vulnerabilities"""
        try:
            parsed_url = urlparse(target if target.startswith('http') else f'https://{target}')
            hostname = parsed_url.hostname
            port = parsed_url.port or 443
            
            # Check SSL certificate
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check for weak ciphers
                    if cipher and 'RC4' in cipher[0]:
                        self._create_finding(
                            session_id,
                            'vulnerability',
                            'medium',
                            'Weak SSL Cipher Suite',
                            f'Server supports weak RC4 cipher: {cipher[0]}',
                            hostname,
                            port,
                            remediation='Disable RC4 cipher suites and use strong encryption'
                        )
                    
                    # Check certificate expiration
                    if cert:
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (not_after - datetime.now()).days
                        
                        if days_until_expiry < 30:
                            severity = 'high' if days_until_expiry < 7 else 'medium'
                            self._create_finding(
                                session_id,
                                'vulnerability',
                                severity,
                                'SSL Certificate Expiring Soon',
                                f'SSL certificate expires in {days_until_expiry} days',
                                hostname,
                                port,
                                remediation='Renew SSL certificate before expiration'
                            )
        
        except Exception as e:
            logging.debug(f"SSL check failed for {target}: {str(e)}")
    
    def _check_service_vulnerabilities(self, session_id, target):
        """Check for service-specific vulnerabilities"""
        try:
            # This would typically involve banner grabbing and version detection
            # For demonstration, we'll check common services
            
            common_ports = [22, 21, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5900]
            
            for port in common_ports:
                if self._is_port_open(target, port):
                    service_info = self._identify_service(target, port)
                    
                    if service_info:
                        vulnerabilities = self._check_service_cves(service_info)
                        for vuln in vulnerabilities:
                            self._create_finding(
                                session_id,
                                'vulnerability',
                                vuln['severity'],
                                f"Known Vulnerability: {vuln['cve_id']}",
                                vuln['description'],
                                target,
                                port,
                                cve_id=vuln['cve_id'],
                                cvss_score=vuln['cvss_score'],
                                remediation=vuln.get('remediation', 'Update to latest version')
                            )
        
        except Exception as e:
            logging.error(f"Service vulnerability check failed: {str(e)}")
    
    def _check_web_vulnerabilities(self, session_id, target):
        """Check for web application vulnerabilities"""
        try:
            if not target.startswith('http'):
                target = f'http://{target}'
            
            # Setup session with proxy if using anonymity
            session = requests.Session()
            if hasattr(self.anonymity, 'get_proxy_config'):
                proxy_config = self.anonymity.get_proxy_config()
                if proxy_config:
                    session.proxies = proxy_config
            
            # Check for common web vulnerabilities
            try:
                response = session.get(target, timeout=10, verify=False)
                
                # Check for missing security headers
                security_headers = [
                    'X-Content-Type-Options',
                    'X-Frame-Options',
                    'X-XSS-Protection',
                    'Strict-Transport-Security',
                    'Content-Security-Policy'
                ]
                
                for header in security_headers:
                    if header not in response.headers:
                        self._create_finding(
                            session_id,
                            'vulnerability',
                            'low',
                            f'Missing Security Header: {header}',
                            f'The {header} security header is not present',
                            target,
                            None,
                            remediation=f'Add {header} header to improve security'
                        )
                
                # Check for server information disclosure
                if 'Server' in response.headers:
                    server_header = response.headers['Server']
                    if any(tech in server_header.lower() for tech in ['apache/', 'nginx/', 'iis/']):
                        self._create_finding(
                            session_id,
                            'vulnerability',
                            'info',
                            'Server Information Disclosure',
                            f'Server header reveals: {server_header}',
                            target,
                            None,
                            remediation='Configure server to hide version information'
                        )
                
                # Check for directory traversal
                traversal_payloads = ['../../../etc/passwd', '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts']
                for payload in traversal_payloads:
                    test_url = urljoin(target, payload)
                    try:
                        resp = session.get(test_url, timeout=5)
                        if resp.status_code == 200 and ('root:' in resp.text or 'localhost' in resp.text):
                            self._create_finding(
                                session_id,
                                'vulnerability',
                                'high',
                                'Directory Traversal Vulnerability',
                                'Server is vulnerable to directory traversal attacks',
                                target,
                                None,
                                remediation='Implement proper input validation and access controls'
                            )
                            break
                    except:
                        continue
            
            except requests.RequestException:
                pass
        
        except Exception as e:
            logging.error(f"Web vulnerability check failed: {str(e)}")
    
    def _check_network_vulnerabilities(self, session_id, target):
        """Check for network-level vulnerabilities"""
        try:
            # Check for common network vulnerabilities
            
            # Check for open administrative ports
            admin_ports = [22, 23, 3389, 5900, 5901, 5902]
            for port in admin_ports:
                if self._is_port_open(target, port):
                    severity = 'high' if port == 23 else 'medium'  # Telnet is critical
                    service_name = {22: 'SSH', 23: 'Telnet', 3389: 'RDP', 5900: 'VNC'}
                    
                    self._create_finding(
                        session_id,
                        'vulnerability',
                        severity,
                        f'Open Administrative Service: {service_name.get(port, f"Port {port}")}',
                        f'Administrative service {service_name.get(port, f"on port {port}")} is accessible',
                        target,
                        port,
                        remediation='Restrict access using firewall rules or VPN'
                    )
            
            # Check for database ports
            db_ports = [1433, 3306, 5432, 1521, 27017]
            for port in db_ports:
                if self._is_port_open(target, port):
                    db_name = {1433: 'SQL Server', 3306: 'MySQL', 5432: 'PostgreSQL', 1521: 'Oracle', 27017: 'MongoDB'}
                    
                    self._create_finding(
                        session_id,
                        'vulnerability',
                        'high',
                        f'Exposed Database: {db_name.get(port, f"Port {port}")}',
                        f'Database service {db_name.get(port, f"on port {port}")} is externally accessible',
                        target,
                        port,
                        remediation='Move database behind firewall and restrict access'
                    )
        
        except Exception as e:
            logging.error(f"Network vulnerability check failed: {str(e)}")
    
    def _is_port_open(self, host, port):
        """Check if a port is open"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except:
            return False
    
    def _identify_service(self, host, port):
        """Identify service running on a port"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((host, port))
            
            # Send basic HTTP request for web services
            if port in [80, 443, 8080, 8443]:
                sock.send(b'GET / HTTP/1.1\r\nHost: ' + host.encode() + b'\r\n\r\n')
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                sock.close()
                
                if 'Server:' in banner:
                    server_line = [line for line in banner.split('\n') if 'Server:' in line][0]
                    return {'service': 'http', 'banner': server_line, 'port': port}
            
            # For other services, try to grab banner
            else:
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
                sock.close()
                
                if banner:
                    return {'service': 'unknown', 'banner': banner, 'port': port}
            
        except:
            pass
        
        return None
    
    def _check_service_cves(self, service_info):
        """Check service against CVE database"""
        vulnerabilities = []
        
        banner = service_info.get('banner', '').lower()
        
        # Simple pattern matching for demonstration
        for service, cves in self.cve_database.items():
            if service in banner:
                for cve_id, cve_info in cves.items():
                    vulnerabilities.append({
                        'cve_id': cve_id,
                        'description': cve_info['description'],
                        'cvss_score': cve_info['cvss_score'],
                        'severity': cve_info['severity']
                    })
        
        return vulnerabilities
    
    def _create_finding(self, session_id, finding_type, severity, title, description, 
                       target_host, target_port, cve_id=None, cvss_score=None, remediation=None):
        """Create and store a security finding"""
        finding = Finding(
            scan_session_id=session_id,
            finding_type=finding_type,
            severity=severity,
            title=title,
            description=encrypt_data(description),
            target_host=encrypt_data(target_host),
            target_port=target_port,
            cve_id=cve_id,
            cvss_score=cvss_score,
            remediation=encrypt_data(remediation) if remediation else None
        )
        
        db.session.add(finding)
        db.session.commit()
    
    def stop_scan(self):
        """Stop the current vulnerability scan"""
        self.is_scanning = False
    
    def get_scan_progress(self, session_id):
        """Get scan progress information"""
        session = ScanSession.query.get(session_id)
        findings_count = Finding.query.filter_by(scan_session_id=session_id).count()
        
        return {
            'status': session.status if session else 'unknown',
            'is_running': self.is_scanning,
            'findings_count': findings_count
        }
