import requests
import json
import re
from datetime import datetime
from security.anonymity import anonymity_manager
from security.encryption import encrypt_data

class VulnerabilityScanner:
    def __init__(self):
        self.anonymity = anonymity_manager
        self.cve_database = {}
        self.vulnerability_signatures = self._load_vulnerability_signatures()
    
    def scan_vulnerabilities(self, target, intensity='medium', include_web=True):
        """Perform comprehensive vulnerability scan"""
        results = {
            'target': target,
            'scan_started': datetime.utcnow().isoformat(),
            'intensity': intensity,
            'vulnerabilities': [],
            'summary': {},
            'recommendations': []
        }
        
        try:
            # Create anonymized session
            session = self.anonymity.create_anonymized_session()
            
            # Service detection vulnerabilities
            service_vulns = self._scan_service_vulnerabilities(target, session)
            results['vulnerabilities'].extend(service_vulns)
            
            # Web application vulnerabilities
            if include_web:
                web_vulns = self._scan_web_vulnerabilities(target, session)
                results['vulnerabilities'].extend(web_vulns)
            
            # Network protocol vulnerabilities
            network_vulns = self._scan_network_vulnerabilities(target, session)
            results['vulnerabilities'].extend(network_vulns)
            
            # SSL/TLS vulnerabilities
            ssl_vulns = self._scan_ssl_vulnerabilities(target, session)
            results['vulnerabilities'].extend(ssl_vulns)
            
            # Generate summary and recommendations
            results['summary'] = self._generate_vulnerability_summary(results['vulnerabilities'])
            results['recommendations'] = self._generate_recommendations(results['vulnerabilities'])
            results['scan_completed'] = datetime.utcnow().isoformat()
            results['status'] = 'completed'
            
        except Exception as e:
            results['error'] = str(e)
            results['status'] = 'failed'
            results['scan_completed'] = datetime.utcnow().isoformat()
        
        return results
    
    def _scan_service_vulnerabilities(self, target, session):
        """Scan for service-specific vulnerabilities"""
        vulnerabilities = []
        
        # Common service vulnerabilities
        common_services = {
            21: 'ftp',
            22: 'ssh',
            23: 'telnet',
            25: 'smtp',
            53: 'dns',
            80: 'http',
            110: 'pop3',
            143: 'imap',
            443: 'https',
            993: 'imaps',
            995: 'pop3s'
        }
        
        for port, service in common_services.items():
            try:
                # Check if port is open
                import socket
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((target, port))
                sock.close()
                
                if result == 0:  # Port is open
                    service_vulns = self._check_service_vulnerabilities(target, port, service)
                    vulnerabilities.extend(service_vulns)
                
                # Add timing obfuscation
                self.anonymity.obfuscate_timing(0.5, 2)
                
            except Exception as e:
                continue
        
        return vulnerabilities
    
    def _check_service_vulnerabilities(self, target, port, service):
        """Check specific service for vulnerabilities"""
        vulnerabilities = []
        
        # SSH vulnerabilities
        if service == 'ssh' and port == 22:
            ssh_vulns = self._check_ssh_vulnerabilities(target, port)
            vulnerabilities.extend(ssh_vulns)
        
        # HTTP/HTTPS vulnerabilities
        elif service in ['http', 'https']:
            web_vulns = self._check_web_service_vulnerabilities(target, port, service)
            vulnerabilities.extend(web_vulns)
        
        # FTP vulnerabilities
        elif service == 'ftp':
            ftp_vulns = self._check_ftp_vulnerabilities(target, port)
            vulnerabilities.extend(ftp_vulns)
        
        return vulnerabilities
    
    def _check_ssh_vulnerabilities(self, target, port):
        """Check SSH specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            import paramiko
            
            # Test for weak authentication
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            # Common weak credentials
            weak_creds = [
                ('root', 'root'),
                ('admin', 'admin'),
                ('root', ''),
                ('admin', 'password'),
                ('test', 'test')
            ]
            
            for username, password in weak_creds:
                try:
                    ssh.connect(target, port=port, username=username, password=password, timeout=5)
                    vulnerabilities.append({
                        'title': 'Weak SSH Credentials',
                        'description': f'SSH service accepts weak credentials: {username}:{password}',
                        'severity': 'critical',
                        'cvss_score': 9.8,
                        'host': target,
                        'port': port,
                        'service': 'ssh',
                        'remediation': 'Implement strong password policies and consider key-based authentication',
                        'details': {
                            'username': username,
                            'password': password,
                            'authentication_method': 'password'
                        }
                    })
                    ssh.close()
                    break
                except paramiko.AuthenticationException:
                    continue
                except Exception:
                    break
            
        except ImportError:
            pass
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_web_service_vulnerabilities(self, target, port, service):
        """Check web service vulnerabilities"""
        vulnerabilities = []
        
        try:
            protocol = 'https' if service == 'https' else 'http'
            base_url = f"{protocol}://{target}:{port}"
            
            session = self.anonymity.create_anonymized_session()
            
            # Check for common web vulnerabilities
            web_vulns = [
                self._check_directory_traversal(base_url, session),
                self._check_xss_vulnerability(base_url, session),
                self._check_sql_injection(base_url, session),
                self._check_security_headers(base_url, session),
                self._check_default_credentials(base_url, session)
            ]
            
            for vuln_list in web_vulns:
                if vuln_list:
                    vulnerabilities.extend(vuln_list)
        
        except Exception as e:
            pass
        
        return vulnerabilities
    
    def _check_directory_traversal(self, base_url, session):
        """Check for directory traversal vulnerability"""
        vulnerabilities = []
        
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
        ]
        
        for payload in traversal_payloads:
            try:
                test_url = f"{base_url}/?file={payload}"
                response = session.get(test_url, timeout=10)
                
                if 'root:x:0:0:' in response.text or 'localhost' in response.text:
                    vulnerabilities.append({
                        'title': 'Directory Traversal Vulnerability',
                        'description': 'Application allows access to system files through path traversal',
                        'severity': 'high',
                        'cvss_score': 7.5,
                        'host': base_url,
                        'service': 'web',
                        'remediation': 'Implement proper input validation and file access controls',
                        'details': {
                            'payload': payload,
                            'vulnerable_parameter': 'file',
                            'response_snippet': response.text[:200]
                        }
                    })
                    break
                
                self.anonymity.obfuscate_timing(0.5, 1.5)
                
            except Exception:
                continue
        
        return vulnerabilities
    
    def _check_xss_vulnerability(self, base_url, session):
        """Check for XSS vulnerabilities"""
        vulnerabilities = []
        
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "';alert('XSS');//",
            '<img src=x onerror=alert("XSS")>',
            'javascript:alert("XSS")'
        ]
        
        # Test common parameters
        test_params = ['q', 'search', 'query', 'name', 'message', 'comment']
        
        for param in test_params:
            for payload in xss_payloads:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    response = session.get(test_url, timeout=10)
                    
                    if payload in response.text and 'text/html' in response.headers.get('content-type', ''):
                        vulnerabilities.append({
                            'title': 'Cross-Site Scripting (XSS)',
                            'description': f'Reflected XSS vulnerability found in parameter: {param}',
                            'severity': 'medium',
                            'cvss_score': 6.1,
                            'host': base_url,
                            'service': 'web',
                            'remediation': 'Implement proper input validation and output encoding',
                            'details': {
                                'parameter': param,
                                'payload': payload,
                                'vulnerability_type': 'reflected_xss'
                            }
                        })
                        break
                    
                    self.anonymity.obfuscate_timing(0.3, 1)
                    
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _check_sql_injection(self, base_url, session):
        """Check for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "1' AND 1=1--"
        ]
        
        test_params = ['id', 'user', 'username', 'search', 'query']
        
        for param in test_params:
            for payload in sql_payloads:
                try:
                    test_url = f"{base_url}/?{param}={payload}"
                    response = session.get(test_url, timeout=10)
                    
                    # Look for SQL error messages
                    error_patterns = [
                        r'SQL syntax.*MySQL',
                        r'Warning.*mysql_',
                        r'MySQLSyntaxErrorException',
                        r'PostgreSQL.*ERROR',
                        r'ORA-[0-9]+',
                        r'Microsoft.*ODBC.*SQL Server'
                    ]
                    
                    for pattern in error_patterns:
                        if re.search(pattern, response.text, re.IGNORECASE):
                            vulnerabilities.append({
                                'title': 'SQL Injection Vulnerability',
                                'description': f'SQL injection vulnerability found in parameter: {param}',
                                'severity': 'critical',
                                'cvss_score': 9.8,
                                'host': base_url,
                                'service': 'web',
                                'remediation': 'Use parameterized queries and input validation',
                                'details': {
                                    'parameter': param,
                                    'payload': payload,
                                    'error_pattern': pattern
                                }
                            })
                            break
                    
                    self.anonymity.obfuscate_timing(0.5, 1.5)
                    
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _check_security_headers(self, base_url, session):
        """Check for missing security headers"""
        vulnerabilities = []
        
        try:
            response = session.get(base_url, timeout=10)
            headers = response.headers
            
            security_headers = {
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'X-Frame-Options': 'Missing X-Frame-Options header',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'Strict-Transport-Security': 'Missing HSTS header',
                'Content-Security-Policy': 'Missing Content Security Policy header'
            }
            
            missing_headers = []
            for header, description in security_headers.items():
                if header not in headers:
                    missing_headers.append(header)
            
            if missing_headers:
                vulnerabilities.append({
                    'title': 'Missing Security Headers',
                    'description': 'Web application missing important security headers',
                    'severity': 'medium',
                    'cvss_score': 5.3,
                    'host': base_url,
                    'service': 'web',
                    'remediation': 'Implement all recommended security headers',
                    'details': {
                        'missing_headers': missing_headers,
                        'current_headers': dict(headers)
                    }
                })
        
        except Exception:
            pass
        
        return vulnerabilities
    
    def _check_default_credentials(self, base_url, session):
        """Check for default admin credentials"""
        vulnerabilities = []
        
        # Common admin login paths
        login_paths = ['/admin', '/login', '/admin/login', '/administrator', '/wp-admin']
        
        # Common default credentials
        default_creds = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', ''),
            ('root', 'root'),
            ('administrator', 'administrator')
        ]
        
        for path in login_paths:
            try:
                login_url = base_url + path
                response = session.get(login_url, timeout=10)
                
                if response.status_code == 200 and ('login' in response.text.lower() or 'password' in response.text.lower()):
                    # Found login page, test default credentials
                    for username, password in default_creds:
                        login_data = {
                            'username': username,
                            'password': password,
                            'user': username,
                            'pass': password
                        }
                        
                        try:
                            auth_response = session.post(login_url, data=login_data, timeout=10)
                            
                            if auth_response.status_code == 200 and 'dashboard' in auth_response.text.lower():
                                vulnerabilities.append({
                                    'title': 'Default Administrative Credentials',
                                    'description': f'Default credentials found: {username}:{password}',
                                    'severity': 'critical',
                                    'cvss_score': 9.8,
                                    'host': base_url,
                                    'service': 'web',
                                    'remediation': 'Change default administrative credentials immediately',
                                    'details': {
                                        'username': username,
                                        'password': password,
                                        'login_path': path
                                    }
                                })
                                break
                            
                            self.anonymity.obfuscate_timing(1, 3)
                            
                        except Exception:
                            continue
                    
                    break
                
            except Exception:
                continue
        
        return vulnerabilities
    
    def _scan_web_vulnerabilities(self, target, session):
        """Comprehensive web application vulnerability scan"""
        vulnerabilities = []
        
        protocols = ['http', 'https']
        common_ports = [80, 443, 8080, 8443, 3000, 5000]
        
        for protocol in protocols:
            for port in common_ports:
                try:
                    base_url = f"{protocol}://{target}:{port}"
                    response = session.get(base_url, timeout=10)
                    
                    if response.status_code == 200:
                        web_vulns = self._check_web_service_vulnerabilities(target, port, protocol.replace('s', ''))
                        vulnerabilities.extend(web_vulns)
                
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _scan_network_vulnerabilities(self, target, session):
        """Scan for network protocol vulnerabilities"""
        vulnerabilities = []
        
        # SMB vulnerabilities (port 445)
        smb_vulns = self._check_smb_vulnerabilities(target)
        vulnerabilities.extend(smb_vulns)
        
        return vulnerabilities
    
    def _check_smb_vulnerabilities(self, target):
        """Check for SMB vulnerabilities"""
        vulnerabilities = []
        
        try:
            import socket
            
            # Check if SMB port is open
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target, 445))
            sock.close()
            
            if result == 0:
                # SMB port is open - check for common vulnerabilities
                vulnerabilities.append({
                    'title': 'SMB Service Exposed',
                    'description': 'SMB service is accessible and may be vulnerable to various attacks',
                    'severity': 'medium',
                    'cvss_score': 5.8,
                    'host': target,
                    'port': 445,
                    'service': 'smb',
                    'remediation': 'Restrict SMB access and ensure latest patches are applied',
                    'details': {
                        'service': 'SMB/CIFS',
                        'port': 445,
                        'potential_vulnerabilities': ['EternalBlue', 'SMBGhost', 'Null Session']
                    }
                })
        
        except Exception:
            pass
        
        return vulnerabilities
    
    def _scan_ssl_vulnerabilities(self, target, session):
        """Scan for SSL/TLS vulnerabilities"""
        vulnerabilities = []
        
        try:
            import ssl
            import socket
            
            # Check HTTPS ports
            https_ports = [443, 8443]
            
            for port in https_ports:
                try:
                    context = ssl.create_default_context()
                    context.check_hostname = False
                    context.verify_mode = ssl.CERT_NONE
                    
                    with socket.create_connection((target, port), timeout=10) as sock:
                        with context.wrap_socket(sock, server_hostname=target) as ssock:
                            cert = ssock.getpeercert()
                            cipher = ssock.cipher()
                            
                            # Check for weak ciphers
                            if cipher and 'RC4' in cipher[0] or 'DES' in cipher[0]:
                                vulnerabilities.append({
                                    'title': 'Weak SSL/TLS Cipher',
                                    'description': f'Weak cipher suite detected: {cipher[0]}',
                                    'severity': 'medium',
                                    'cvss_score': 5.9,
                                    'host': target,
                                    'port': port,
                                    'service': 'https',
                                    'remediation': 'Configure server to use only strong cipher suites',
                                    'details': {
                                        'cipher': cipher[0],
                                        'protocol': cipher[1],
                                        'key_bits': cipher[2]
                                    }
                                })
                            
                            # Check certificate validity
                            if cert:
                                import datetime
                                not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                                
                                if not_after < datetime.datetime.now():
                                    vulnerabilities.append({
                                        'title': 'Expired SSL Certificate',
                                        'description': 'SSL certificate has expired',
                                        'severity': 'high',
                                        'cvss_score': 7.5,
                                        'host': target,
                                        'port': port,
                                        'service': 'https',
                                        'remediation': 'Renew SSL certificate immediately',
                                        'details': {
                                            'subject': cert.get('subject'),
                                            'issuer': cert.get('issuer'),
                                            'not_after': cert.get('notAfter')
                                        }
                                    })
                
                except Exception:
                    continue
        
        except ImportError:
            pass
        except Exception:
            pass
        
        return vulnerabilities
    
    def _check_ftp_vulnerabilities(self, target, port):
        """Check FTP specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            import ftplib
            
            # Test anonymous FTP access
            try:
                ftp = ftplib.FTP()
                ftp.connect(target, port, timeout=10)
                ftp.login()  # Anonymous login
                
                vulnerabilities.append({
                    'title': 'Anonymous FTP Access',
                    'description': 'FTP server allows anonymous access',
                    'severity': 'medium',
                    'cvss_score': 5.3,
                    'host': target,
                    'port': port,
                    'service': 'ftp',
                    'remediation': 'Disable anonymous FTP access if not required',
                    'details': {
                        'access_type': 'anonymous',
                        'authentication': 'none_required'
                    }
                })
                
                ftp.quit()
                
            except ftplib.error_perm:
                pass  # Anonymous access denied - good
            except Exception:
                pass
        
        except ImportError:
            pass
        
        return vulnerabilities
    
    def _generate_vulnerability_summary(self, vulnerabilities):
        """Generate vulnerability summary statistics"""
        summary = {
            'total_vulnerabilities': len(vulnerabilities),
            'by_severity': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0, 'info': 0},
            'by_type': {},
            'highest_cvss': 0,
            'affected_services': []
        }
        
        for vuln in vulnerabilities:
            # Count by severity
            severity = vuln.get('severity', 'info')
            summary['by_severity'][severity] += 1
            
            # Track highest CVSS score
            cvss = vuln.get('cvss_score', 0)
            if cvss > summary['highest_cvss']:
                summary['highest_cvss'] = cvss
            
            # Count by vulnerability type
            vuln_type = vuln.get('title', 'Unknown')
            summary['by_type'][vuln_type] = summary['by_type'].get(vuln_type, 0) + 1
            
            # Track affected services
            service = vuln.get('service', 'unknown')
            if service not in summary['affected_services']:
                summary['affected_services'].append(service)
        
        return summary
    
    def _generate_recommendations(self, vulnerabilities):
        """Generate remediation recommendations"""
        recommendations = []
        
        # Critical vulnerabilities first
        critical_vulns = [v for v in vulnerabilities if v.get('severity') == 'critical']
        if critical_vulns:
            recommendations.append({
                'priority': 'critical',
                'title': 'Address Critical Vulnerabilities Immediately',
                'description': f'Found {len(critical_vulns)} critical vulnerabilities requiring immediate attention',
                'actions': [
                    'Patch all systems with critical vulnerabilities',
                    'Change default credentials immediately',
                    'Implement network segmentation',
                    'Monitor for exploitation attempts'
                ]
            })
        
        # Web application security
        web_vulns = [v for v in vulnerabilities if v.get('service') == 'web']
        if web_vulns:
            recommendations.append({
                'priority': 'high',
                'title': 'Improve Web Application Security',
                'description': f'Found {len(web_vulns)} web application vulnerabilities',
                'actions': [
                    'Implement input validation and output encoding',
                    'Add security headers to all responses',
                    'Use parameterized queries to prevent SQL injection',
                    'Implement proper authentication and authorization'
                ]
            })
        
        # Network security
        network_vulns = [v for v in vulnerabilities if v.get('service') in ['ssh', 'ftp', 'smb']]
        if network_vulns:
            recommendations.append({
                'priority': 'medium',
                'title': 'Strengthen Network Security',
                'description': f'Found {len(network_vulns)} network service vulnerabilities',
                'actions': [
                    'Disable unnecessary network services',
                    'Implement strong authentication mechanisms',
                    'Use network firewalls to restrict access',
                    'Enable logging and monitoring'
                ]
            })
        
        return recommendations
    
    def _load_vulnerability_signatures(self):
        """Load vulnerability signatures and patterns"""
        return {
            'web_signatures': {
                'sql_injection': [
                    r'SQL syntax.*MySQL',
                    r'Warning.*mysql_',
                    r'ORA-[0-9]+',
                    r'Microsoft.*ODBC.*SQL Server'
                ],
                'xss_patterns': [
                    r'<script.*?>.*?</script>',
                    r'javascript:',
                    r'on\w+\s*='
                ]
            },
            'service_signatures': {
                'ssh_weak_auth': [
                    'password authentication',
                    'keyboard-interactive'
                ],
                'ftp_anonymous': [
                    'anonymous FTP',
                    '230 Anonymous user logged in'
                ]
            }
        }
